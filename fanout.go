package tools

// Fanout позволяет раздавать данные для обработки всем зарегистрированным слушателям.
type Fanout[K comparable, V any] struct {
	listens Map[K, chan V] // список слушателей
}

// Listen регистрирует нового слушателя и возвращает канал для получения всех сообщений.
// Если канал с таким идентификатором уже зарегистрирован, то возвращается nil, чтобы избещать
// перехвата сообщений другим обработчиком, зарегистрированным с тем же идентификатором.
func (f *Fanout[K, V]) Listen(id K) <-chan V {
	if _, ok := f.listens.Load(id); ok {
		return nil
	}

	ch := make(chan V)      // инициализируем канал
	f.listens.Store(id, ch) // сохраняем его в списке приёмников

	return ch // возвращаем канал для чтения
}

// Unlisten отменяет регистрацию и закрывает ранее полученный при регистрации канал.
// Если слушатель с таким идентификатором не зарегистрирован, то это не вызывает проблем
// и просто игнорируется.
func (f *Fanout[K, V]) Unlisten(id K) {
	ch, ok := f.listens.Load(id) // получаем канал по идентификатору
	if !ok {
		return // канал не зарегистрирован
	}

	f.listens.Delete(id) // удаляем слушателя из списка
	close(ch)            // закрываем канал
}

// Notify отсылает данные всем зарегистрированным слушателям.
//
// Это блокирующая операция, которая завершает свою работу только после того,
// как все зарегистрированные слушатели получат переданные данные.
// Данные каждому слушателю передаются все сразу, если их больше одного.
func (f *Fanout[K, V]) Notify(data ...V) {
	if len(data) == 0 {
		return
	}

	// отсылаем данные во все каналы обработки
	f.listens.Range(func(_ K, ch chan V) bool {
		for _, d := range data {
			ch <- d
		}

		return true
	})
}
